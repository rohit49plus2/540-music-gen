import os
from glob import glob
import pickle
from music21 import converter, instrument, note, chord, stream
import numpy as np
import play
import random

dir_path = os.path.dirname(os.path.realpath(__file__))
songs = glob(dir_path+'/data/*.mid')
print(songs)

def get_notes():
    notes = []
    durations = []
    for file in songs:
        # converting .mid file to stream object
        midi = converter.parse(file)
        notes_to_parse = []
        try:
        # Given a single stream, partition into a part for each unique instrument
            parts = instrument.partitionByInstrument(midi)
        except:
            pass
        if parts: # if parts has instrument parts
            notes_to_parse = parts.parts[0].recurse()
        else:
            notes_to_parse = midi.flat.notes
        for element in notes_to_parse:
            if isinstance(element, note.Note):
                notes.append(str(element.pitch))
                durations.append(element.duration.quarterLength)
            elif(isinstance(element, chord.Chord)):
                notes.append('.'.join(str(n) for n in element.normalOrder))
                durations.append(element.duration.quarterLength)
    
    return (notes, durations)

def prepare_sequences(notes, durations, sequence_length):

    # Extract the unique pitches in the list of notes.
    pitchnames = sorted(set(item for item in notes))
    timings = sorted(set(item for item in durations))
    
    # create a dictionary to map pitches to integers
    network_input_note = []
    network_output_note = []
    network_input_dur = []
    network_output_dur = []

    # create input sequences and the corresponding outputs
    for i in range(0, len(notes) - sequence_length, 1):
        network_input_note.append(notes[i: i + sequence_length])
        network_output_note.append(notes[i + sequence_length])


    for i in range(0, len(durations) - sequence_length, 1):
        network_input_dur.append(durations[i: i + sequence_length])
        network_output_dur.append(durations[i + sequence_length])
    
    # one hot encode the output vectors
    network_input_note = np.array(network_input_note)
    network_output_note = np.array(network_output_note)
    network_input_dur = np.array(network_input_dur)
    network_output_dur = np.array(network_output_dur)

    return (network_input_note, network_output_note, network_input_dur, network_output_dur, pitchnames, timings)

def get_transition(notes, network_in, pitchnames, order):

    transition = np.zeros((len(pitchnames), ) * (order+1)).astype(np.short)
    for i in range(len(network_in)):
        for j in range(len(network_in[i]) - order):
            ind = [pitchnames.index(network_in[i][j+o]) for o in range(order+1)]

            transition[ind[0]][ind[1]] += 1
    
    transition = transition/len(network_in)
    transition = transition/sum(transition)

    return transition

def generate(transition, network_input, pitchnames, order):
    start = np.random.randint(0, len(network_input)-1)
    pattern = list(network_input[start])[-order:]

    prediction_output = []
    print("generating notes--")

    prediction_output.extend(pattern)
    for note_index in range(250):
        ind = [pitchnames.index(prediction_output[-order:][o]) for o in range(order)]
        tr = transition[ind[0]]
        pred = np.nanargmax(tr)
        prediction_output.append(pitchnames[pred])

    return prediction_output

def create_midi(pred_note, pred_dur, filename):
    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for i in range(len(pred_note)):
        # pattern is a chord
        pattern = pred_note[i]
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            new_chord.duration.quarterLength = pred_dur[i]
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            new_note.duration.quarterLength = pred_dur[i]
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 0.5

    midi_stream = stream.Stream(output_notes)
    print('Saving Output file as midi....')
    midi_stream.write('midi', fp=filename)

notes, durations = get_notes()
sequence_length = 100

network_in_note, network_out_note, network_in_dur, network_out_dur, pitchnames, timings = prepare_sequences(notes, durations, sequence_length)

order=1
transition_note = get_transition(notes, network_in_note, pitchnames, order)
transition_dur = get_transition(durations, network_in_dur, timings, order)

pred_note = generate(transition_note, network_in_note, pitchnames, order)
pred_dur = generate(transition_dur, network_in_dur, timings, order)

filename = dir_path+'/file.mid'
create_midi(pred_note, pred_dur, filename)
play.play_midi(filename)